
# 70. Linux: стандартные средства для наблюдения счетчиков ядра.

Историческая утилита - **sar** (system activity reporter). Существует почти с самого начала Linux, имеет самый обширный сбор счётчиков.

Собирает статистику по:
- пейджингу (-В)
- свопингу (-W)
- вводу-выводу (-b,-d)
- смонтированным системам (-F)
- прерываниям (-I)
- управлению питанием (-m)
- сети (-n)
- процессорам (-Р,-u)
- очереди процессов и загрузке (-q,-w)
- памяти (-r)
- области подкачки (-s)
- терминалам (-у)

Важная особенность: на утилиту можно настроить кронячку - запуск по расписанию со сбором информации и сохранением логов, которые потом читаем. Другие утилиты так настраивать нельзя.

<img src=img/70.1.png width=500>

### Прочие утилиты.

**Процессор:** ps, top, tiptop, turbostat, ramsr, numastat, uptime

**Виртуальная память:** vmstat, slabtop, pidstat, free

**Дисковая подсистема:** iostat, iotop, blktrace

**Сеть:** netstat, topdump, iptraf, ethtool, nicstat, ip

Утилиты делятся на два вида: Интерактивные (типа top) или с указанием количества запуска и интервала (типа sar)

---

# 71. Linux: файловая система /proc.

/proc - виртуальная файловая система (директория), содержащая файлы статистики и управляющие модули ядра. Т.е. свойства представляются в виде файла

Основные параметры:

- /proc/cpuinfo - информация о процессоре ( модель, семейство, размер кэша и т.д.)

- /proc/meminfo - информация о памяти, размере области подкачки и т.д.

- /proc/mounts - список смонтированных файловых систем.

- /proc/devices - список устройств.

- /proc/filesystems - поддерживаемые файловые системы.

- /proc/modules - список загружаемых модулей.

- /proc/version - версия ядра.

- /proc/cmdline - список параметров, передаваемых ядру при загрузке.

Расшифровка содержимого находится по адресу *root/Documentation/filesystems/proc.rst* в репозитории ядра линукса.

Некоторые файлы можно менять на лету, в рантайме и система будет реагировать на изменения. Например, вызов отладчика ядра.

В
```bash
cd /proc/<pid>
```
хранится большое количество информации о процессе:

<img src=img/71.1.png width=500>

---

# 72. Linux: трассировщики системных вызовов и библиотек.

<img src=img/72.1.png width=500>

Буквально выводит историю вызовов, как они вызывались в ядре, с переданными аргументами и возвращаемым значением. Используется, чтобы посмотреть логику взаимодействия на уровне вызовов.

*strace ls* трассирует все запущенные вами программы, -p конкретный процесс.

Трассировка системных вызовов: *strace*

Трассировка вызовов библиотек: *ltrace*

Трассировка lock -оф(ф): *bpftrace*

---

# 73. Linux: Профилировщик perf и FlameGraph.

Профилировщик смотрит программу более глубоко, чем трассировщики. Швейцарский нож в профилировании: 
```bash
perf
```

Слайд для ознакомления с возможностями перфа:

<img src=img/73.1.png width=700>

Принцип работы:
1) Профилировщик собирает системную информацию, которую вы ему указали.
2) Запускаете perf record, указывая ему профилируемую команду или часть системы.
3) perf маппит ячейки памяти под данные, подсовывает их ядру, ядро записывает туда дизасемблированные собранные данные.
4) perf полученные данные записывает в файл perf.data
5) Собранную статистику можно просмотреть при помощи perf report или воспользоваться автоматическими средствами (perf script), которые не входят в стандартный набор Linux - например, FlameGraph.

**FlameGraph** - выводит собранную перфом информацию в виде графика таймлайн х стек_вызовов, раскрашивая в разные цвета вызовы на уровне ядра, вызовы приложения и библиотек.

<img src=img/73.2.png width=500>

---

# 74. Linux: SystemTap.

SystemTap — это средство, которое позволяет собирать и анализировать информацию о работающей Linux системе.

В отличие от встроенных средств, таких как netstat, ps, top, SystemTap был разработан с целью предоставить больше возможностей для сбора и представления информации.

SystemTap представляет из себя интерфейс командной строки и скриптовый язык программирования.

Используется для мониторинга и анализа производительности системы и анализа поведения приложения в работающей системе.

Принцип работы:

<img src=img/74.1.png width=700>

Пользователь выбирает, куда воткнуть "пробу" (в начало или конец функции, системного вызова и т.п.). Скрипт берёт инструкцию, на место которой добавляется проба, включает её в начало обработчика пробы, а на её место вставляет вызов прерывания.

Использование:

<img src=img/74.2.png width=400>

Для наглядности + понятности:

<img src=img/74.3.png width=400>
<img src=img/74.4.png width=400>

Алгоритм работы - программа запускается, работает, собирает информацию, наращивает счётчики. При остановке выводит собранную информацию (по идее можно вывод в процессе реализовать, но звучит как кал).
С утилитой поставляется набор различных обработчиков информации. Например, утилита может агрегировать собранную информацю и строить графики на её основе.

---

# 75. Linux: Отладчик ядра.

<img src=img/75.1.png width=400>

Есть две версии:

1) Локальный отладчик. Если при компиляции ядра стоят определённые опции и установлена специальная опция при загрузке системы, запускает мини-оболочку с терминала и позволяет посмотреть, что происходит в вашем живом ядре (распечатать содержимое памяти, буферов сообщений и т.д., список команд выдаётся по "?").

2) Отладка удалённой ОС. Запускается с информацией о сериальном порте (физический или виртуальный, напр. VirtualBox). Ничего необычного, при помощи gdb кидаете команды на удалённую машину и дебажите ядро.

Опция для локального запуска: *kgdboc=kbd* . Выставляется в */etc/default/grub* или в меню загрузки, добавляет системе возможность локального дебага.
Чтобы активировать отладчик:
```bash
echo g > /proc/sysrq-trigger
```
После чего система встанет и запустится отладчик. Можно походить по структурам ядра, посмотреть информацию и запустить систему.
- вызов справки: ?
- запустить обратно систему: go